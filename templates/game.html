{% extends 'base.html' %}
{% block content %}
    <div id="noneSection">
        <h1 id="noneTitle">You're in!</h1>
        <p>Please wait for further instructions</p>
    </div>

    <div id="drawingSection" style="display:none;">
        <canvas id="drawingCanvas" width="800" height="600" style="border:1px solid #000000;"></canvas>
        <div>
            <div class="draw-parts">
                <div class="draw-part">
                    <label for="colorPicker">Pick a color:</label>
                    <select id="colorPicker">
                        <option value="#000000">Black</option>
                        <option value="#FF0000">Red</option>
                        <option value="#00FF00">Green</option>
                        <option value="#0000FF">Blue</option>
                        <option value="#FFFF00">Yellow</option>
                        <option value="#FF00FF">Magenta</option>
                        <option value="#00FFFF">Cyan</option>
                        <option value="#FFFFFF">White</option>
                    </select>
                </div>
                <div class="draw-part">
                    <label for="brushSize">Brush Size:</label>
                    <input type="range" id="brushSize" min="1" max="20" value="5">
                </div>
            </div>
            <button onclick="saveDrawing()">Already finished!</button>
        </div>
    </div>

    <script type="text/javascript">
        let socket = io();
        const canvas = document.getElementById('drawingCanvas');
        const ctx = canvas.getContext('2d');
        const drawingSection = document.getElementById('drawingSection');
        const noneSection = document.getElementById('noneSection');
        let drawing = false;
        let currentColor = "#000000";
        let brushSize = 5;

        socket.emit('identify', {'username': "{{ username }}"});

        drawingSection.style.display = "none";

        socket.on('set_page', (page) => {
            if (page === "draw") {
                noneSection.style.display = "none";
                drawingSection.style.display = null;
            } else {
                noneSection.style.display = null;
                drawingSection.style.display = "none";
            }

            if (page !== "draw") {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
            }
        });

        canvas.addEventListener('mousedown', () => drawing = true);
        window.addEventListener('mouseup', () => {
            drawing = false;
            ctx.beginPath();
        });
        canvas.addEventListener('mousemove', draw);

        document.getElementById('colorPicker').addEventListener('change', function () {
            currentColor = this.value;
        });

        document.getElementById('brushSize').addEventListener('input', function () {
            brushSize = this.value;
        });

        function draw(event) {
            if (!drawing) return;
            const rect = canvas.getBoundingClientRect();

            ctx.strokeStyle = currentColor;
            ctx.lineWidth = brushSize * 2;
            ctx.lineCap = 'round';

            ctx.lineTo(event.clientX - rect.left, event.clientY - rect.top);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(event.clientX - rect.left, event.clientY - rect.top);
        }

        function saveDrawing() {
            const image = canvas.toDataURL('image/png');
            socket.emit('save_drawing', {image: image});

            fetch('/save_image/{{ username }}', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({image: image}),
            })
                .then(response => response.text())
                .then(data => {
                    alert(data);
                })
                .catch(error => {
                    console.error('Error:', error);
                });
        }

        socket.on('connect_error', (error) => {
            alert("An unknown error occurred while trying to connect to the server. Please log in again or start a new game.");
            window.location.replace("/");
        });

        socket.on('connect_timeout', (timeout) => {
            alert("Your connection timed out. Please log in again or start a new game.");
            window.location.replace("/");
        });

        socket.on('reconnect_failed', (error) => {
            alert("An unknown error occurred while trying to REconnect to the server. Please log in again or start a new game.");
            window.location.replace("/");
        });

        async function boot() {
            const ticker = setInterval(async () => {
                await updateGame();
            }, 200);
        }

        async function updateGame() {

        }

        boot();
    </script>
{% endblock %}